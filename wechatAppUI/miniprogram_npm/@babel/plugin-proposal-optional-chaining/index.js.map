{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _pluginSyntaxOptionalChaining = _interopRequireDefault(require(\"@babel/plugin-syntax-optional-chaining\"));\n\nvar _core = require(\"@babel/core\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    loose = false\n  } = options;\n\n  function isSimpleMemberExpression(expression) {\n    return _core.types.isIdentifier(expression) || _core.types.isSuper(expression) || _core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);\n  }\n\n  return {\n    name: \"proposal-optional-chaining\",\n    inherits: _pluginSyntaxOptionalChaining.default,\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        const {\n          scope\n        } = path;\n        let maybeParenthesized = path;\n        const parentPath = path.findParent(p => {\n          if (!p.isParenthesizedExpression()) return true;\n          maybeParenthesized = p;\n        });\n        let isDeleteOperation = false;\n        const parentIsCall = parentPath.isCallExpression({\n          callee: maybeParenthesized.node\n        }) && path.isOptionalMemberExpression();\n        const optionals = [];\n        let optionalPath = path;\n\n        while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression() || optionalPath.isParenthesizedExpression() || optionalPath.isTSNonNullExpression()) {\n          const {\n            node\n          } = optionalPath;\n\n          if (node.optional) {\n            optionals.push(node);\n          }\n\n          if (optionalPath.isOptionalMemberExpression()) {\n            optionalPath.node.type = \"MemberExpression\";\n            optionalPath = optionalPath.get(\"object\");\n          } else if (optionalPath.isOptionalCallExpression()) {\n            optionalPath.node.type = \"CallExpression\";\n            optionalPath = optionalPath.get(\"callee\");\n          } else {\n            optionalPath = optionalPath.get(\"expression\");\n          }\n        }\n\n        let replacementPath = path;\n\n        if (parentPath.isUnaryExpression({\n          operator: \"delete\"\n        })) {\n          replacementPath = parentPath;\n          isDeleteOperation = true;\n        }\n\n        for (let i = optionals.length - 1; i >= 0; i--) {\n          const node = optionals[i];\n\n          const isCall = _core.types.isCallExpression(node);\n\n          const replaceKey = isCall ? \"callee\" : \"object\";\n          const chain = node[replaceKey];\n          let ref;\n          let check;\n\n          if (loose && isCall && isSimpleMemberExpression(chain)) {\n            check = ref = chain;\n          } else {\n            ref = scope.maybeGenerateMemoised(chain);\n\n            if (ref) {\n              check = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), chain);\n              node[replaceKey] = ref;\n            } else {\n              check = ref = chain;\n            }\n          }\n\n          if (isCall && _core.types.isMemberExpression(chain)) {\n            if (loose && isSimpleMemberExpression(chain)) {\n              node.callee = chain;\n            } else {\n              const {\n                object\n              } = chain;\n              let context = scope.maybeGenerateMemoised(object);\n\n              if (context) {\n                chain.object = _core.types.assignmentExpression(\"=\", context, object);\n              } else if (_core.types.isSuper(object)) {\n                context = _core.types.thisExpression();\n              } else {\n                context = object;\n              }\n\n              node.arguments.unshift(_core.types.cloneNode(context));\n              node.callee = _core.types.memberExpression(node.callee, _core.types.identifier(\"call\"));\n            }\n          }\n\n          let replacement = replacementPath.node;\n\n          if (i === 0 && parentIsCall) {\n            var _baseRef;\n\n            const {\n              object\n            } = replacement;\n            let baseRef;\n\n            if (!loose || !isSimpleMemberExpression(object)) {\n              baseRef = scope.maybeGenerateMemoised(object);\n\n              if (baseRef) {\n                replacement.object = _core.types.assignmentExpression(\"=\", baseRef, object);\n              }\n            }\n\n            replacement = _core.types.callExpression(_core.types.memberExpression(replacement, _core.types.identifier(\"bind\")), [_core.types.cloneNode((_baseRef = baseRef) != null ? _baseRef : object)]);\n          }\n\n          replacementPath.replaceWith(_core.types.conditionalExpression(loose ? _core.types.binaryExpression(\"==\", _core.types.cloneNode(check), _core.types.nullLiteral()) : _core.types.logicalExpression(\"||\", _core.types.binaryExpression(\"===\", _core.types.cloneNode(check), _core.types.nullLiteral()), _core.types.binaryExpression(\"===\", _core.types.cloneNode(ref), scope.buildUndefinedNode())), isDeleteOperation ? _core.types.booleanLiteral(true) : scope.buildUndefinedNode(), replacement));\n          replacementPath = replacementPath.get(\"alternate\");\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"]}